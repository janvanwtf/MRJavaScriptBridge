/*
 * Author: Jan Van Boghout <github@janvan.wtf>
 *
 * Copyright (c) 2011-2018 MacRabbit.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the
 * Software, and to prepare derivative works of the Software, and
 * to permit third-parties to whom the Software is furnished to do
 * so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the
 * following disclaimer, must be included in all copies of the
 * Software, in whole or in part, and all derivative works of the
 * Software, unless such copies or derivative works are solely in
 * the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#if __has_feature(objc_arc)
#error This file must be compiled without ARC. Either turn ARC off for the project or use -fno-objc-arc flag.
#endif

#import "MRJSContext.h"
#import "MRJSContext-Private.h"
#import "MRJSTypes.h"
#import <objc/objc-class.h>


 JSValueRef MRJSContextGlobalGetProperty            (JSContextRef, JSObjectRef, JSStringRef, JSValueRef *);
       bool MRJSContextGlobalSetProperty            (JSContextRef, JSObjectRef, JSStringRef, JSValueRef value, JSValueRef *);
 JSValueRef MRJSContextIncludeBlockCallAsFunction   (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
       void MRJSContextIncludeBlockFinalize         (JSObjectRef);
JSObjectRef MRJSWrappedClassCallAsConstructor       (JSContextRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
 JSValueRef MRJSWrappedObjectGetProperty            (JSContextRef, JSObjectRef, JSStringRef, JSValueRef *);
       bool MRJSWrappedObjectSetProperty            (JSContextRef, JSObjectRef, JSStringRef, JSValueRef value, JSValueRef *);
       void MRJSWrappedObjectFinalize               (JSObjectRef);
 JSValueRef MRJSWrappedMethodCallAsFunctionVoid     (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
 JSValueRef MRJSWrappedMethodCallAsFunctionId       (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
 JSValueRef MRJSWrappedMethodCallAsFunctionBOOL     (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
 JSValueRef MRJSWrappedMethodCallAsFunctionVoid_allowsLossyArgumentConversion (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
 JSValueRef MRJSWrappedMethodCallAsFunctionId_allowsLossyArgumentConversion   (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);
 JSValueRef MRJSWrappedMethodCallAsFunctionBOOL_allowsLossyArgumentConversion (JSContextRef, JSObjectRef, JSObjectRef, size_t, const JSValueRef[], JSValueRef *);


NS_INLINE BOOL MRJSCheckEqualObjCType(const char *typeA, const char *typeB)
{
    return (strcmp(typeA, typeB) == 0);
}

NS_INLINE BOOL MRJSCheckEqualAndFreeCopiedObjCType(char *copiedType, const char *expectedType)
{
    if (copiedType != NULL) {
        BOOL isEqual = MRJSCheckEqualObjCType(copiedType, expectedType);
        free(copiedType);
        return isEqual;
    }
    return NO;
}


typedef id (^MRJSConstructor)(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef *exception);


#define NEW_OPAQUE_TO_OBJECT_MAP [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsOpaqueMemory|NSPointerFunctionsOpaquePersonality valueOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality capacity:0]
#define NEW_OBJECT_TO_OPAQUE_MAP [[NSMapTable alloc] initWithKeyOptions:NSPointerFunctionsStrongMemory|NSPointerFunctionsObjectPersonality valueOptions:NSPointerFunctionsOpaqueMemory|NSPointerFunctionsOpaquePersonality capacity:0]

static void *___nullStaticVariable = NULL;
#define nullToken ((void *)(&___nullStaticVariable))
#define nullSelector (@selector(null))

static JSStringRef kMRJSPropertyLength = NULL; // "length"



#pragma mark -


NSErrorDomain const MRJSContextErrorDomain = @"MRJSContextErrorDomain";
NSErrorUserInfoKey const MRJSContextErrorOriginKey = @"MRJSContextErrorOriginKey";
NSErrorUserInfoKey const MRJSContextErrorLineNumberKey = @"MRJSContextErrorLineNumberKey";
NSErrorUserInfoKey const MRJSContextErrorStackTraceKey = @"MRJSContextErrorStackTraceKey";


@implementation MRJSContext
{
    NSString *identifier_;
    MRJSConsole *console_;
    
    JSContextGroupRef ctxGroup_;
    JSGlobalContextRef ctx_;
    JSValueRef arrayPrototype_;
    
    NSMapTable *classNameToConstructorObjectClassMap_;
    NSMapTable *globalPropertyToConstantJSValueMap_;
    NSMapTable *classToFunctionNameToJSFunctionMap_;
    NSMapTable *classToPropertyNameToObjectGetterMap_;
    NSMapTable *classToPropertyNameToObjectSetterMap_;
    NSMapTable *classToPropertyNameToJSValueGetterMap_;
    NSMapTable *classToPropertyNameToJSValueSetterMap_;
    BOOL canSetGlobalProperties_;
    NSUInteger canSetGlobalPropertiesOverride_;
    
    NSMutableSet *_protectedValues;
}

@synthesize canSetGlobalProperties=canSetGlobalProperties_;


- (instancetype)initWithIdentifier:(NSString *)identifier
{
    static JSClassRef globalObjectClass;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        
        kMRJSPropertyLength = JSStringCreateWithUTF8CString("length");
        
        JSClassDefinition definition = kJSClassDefinitionEmpty;
        definition.className = "MRJSContext";
        definition.getProperty = MRJSContextGlobalGetProperty;
        definition.setProperty = MRJSContextGlobalSetProperty;
        
        globalObjectClass = JSClassCreate(&definition);
    });
    
    
    
    self = [super init];
    if (self == nil)
        return nil;
    
    identifier_ = [identifier retain];
    classNameToConstructorObjectClassMap_ = NEW_OBJECT_TO_OPAQUE_MAP;
    globalPropertyToConstantJSValueMap_ = NEW_OBJECT_TO_OPAQUE_MAP;
    
    classToFunctionNameToJSFunctionMap_ = NEW_OPAQUE_TO_OBJECT_MAP;
    classToPropertyNameToObjectGetterMap_ = NEW_OPAQUE_TO_OBJECT_MAP;
    classToPropertyNameToObjectSetterMap_ = NEW_OPAQUE_TO_OBJECT_MAP;
    classToPropertyNameToJSValueGetterMap_ = NEW_OPAQUE_TO_OBJECT_MAP;
    classToPropertyNameToJSValueSetterMap_ = NEW_OPAQUE_TO_OBJECT_MAP;
    
    ctxGroup_ = JSContextGroupCreate();
    ctx_ = JSGlobalContextCreateInGroup(ctxGroup_, globalObjectClass);
    
    JSObjectRef globalObject = JSContextGetGlobalObject(ctx_);
    if (globalObject != NULL) {
        JSObjectSetPrivate(globalObject, self);
    }
    
    // Keep around standard type info for detection purposes
    JSObjectRef testArray = JSObjectMakeArray(ctx_, 0, NULL, NULL);
    if (testArray != NULL) {
        arrayPrototype_ = JSObjectGetPrototype(ctx_, testArray);
        [self _protectValue:arrayPrototype_];
    }

    // Add the console object
    console_ = [[MRJSConsole alloc] init];
    if (identifier_ != nil) {
        [console_ setLogPrefix:[NSString stringWithFormat:@"[%@] ", identifier_]];
    }
    [self addConstant:console_ withName:@"console"];
    
    return self;
}

- (instancetype)init
{
    return [self initWithIdentifier:nil];
}

- (void)dealloc
{
    JSObjectRef globalObject = JSContextGetGlobalObject(ctx_);
    if (globalObject != NULL) {
        JSObjectSetPrivate(globalObject, nil);
    }
    
    [self _unprotectAllValues];
    
    JSGlobalContextRelease(ctx_);
    JSContextGroupRelease(ctxGroup_);
    ctx_ = NULL;
    ctxGroup_ = NULL;
    
    [classNameToConstructorObjectClassMap_ release];
    [globalPropertyToConstantJSValueMap_ release];
    [classToFunctionNameToJSFunctionMap_ release];
    [classToPropertyNameToObjectGetterMap_ release];
    [classToPropertyNameToObjectSetterMap_ release];
    [classToPropertyNameToJSValueGetterMap_ release];
    [classToPropertyNameToJSValueSetterMap_ release];
    [console_ release];
    [identifier_ release];
    [_protectedValues release];
    
    [super dealloc];
}

#pragma mark -

- (void)_protectValue:(JSValueRef)valueRef
{
    if (valueRef == nil || valueRef == nullToken) {
        return;
    }
    
    NSValue *valueWrapper = [NSValue valueWithPointer:valueRef];
    
    if ([_protectedValues containsObject:valueWrapper]) {
        return;
    }
    
    JSValueProtect(ctx_, valueRef);

    _protectedValues = _protectedValues ?: [[NSMutableSet alloc] init];
    [_protectedValues addObject:valueWrapper];
}

- (void)_unprotectValue:(JSValueRef)valueRef
{
    if (valueRef == nil || valueRef == nullToken) {
        return;
    }

    NSValue *valueWrapper = [NSValue valueWithPointer:valueRef];
    
    if (![_protectedValues containsObject:valueWrapper]) {
        return;
    }
    
    JSValueUnprotect(ctx_, valueRef);
    [_protectedValues removeObject:valueWrapper];
}

- (void)_unprotectAllValues
{
    for (NSValue *valueWrapper in _protectedValues) {
        JSValueRef valueRef = [valueWrapper pointerValue];
        JSValueUnprotect(ctx_, valueRef);
    }
    
    [_protectedValues removeAllObjects];
}

#pragma mark -

- (JSValueRef)arrayPrototype
{
    return arrayPrototype_;
}

- (void)setJSValue:(JSValueRef)newValue forGlobalProperty:(NSString *)propertyName
{
    JSValueRef existingValue = NSMapGet(globalPropertyToConstantJSValueMap_, propertyName);
    
    if (existingValue != NULL && existingValue != nullToken) {
        NSMapInsert(globalPropertyToConstantJSValueMap_, propertyName, nullToken);
        [self _unprotectValue:existingValue];
    }
    
    if (newValue != NULL) {
        NSMapInsert(globalPropertyToConstantJSValueMap_, propertyName, newValue);
        [self _protectValue:newValue];
    }
}

#pragma mark -

static JSClassRef MRJSWrappedObjectJSClass()
{
    static JSClassRef wrappedObjectClass;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        
        JSClassDefinition definition = kJSClassDefinitionEmpty;
        definition.className = "MRJSWrappedObject";
        definition.finalize = MRJSWrappedObjectFinalize;
        definition.getProperty = MRJSWrappedObjectGetProperty;
        definition.setProperty = MRJSWrappedObjectSetProperty;
        
        wrappedObjectClass = JSClassCreate(&definition);
    });
    
    return wrappedObjectClass;
}

static id MRJSMakeObjectForJSValue(JSContextRef ctx, JSValueRef value, BOOL allowsLossyConversion)
{
    if (value == NULL) {
        return nil;
    }
    
    JSType type = JSValueGetType(ctx, value);
    if (type == kJSTypeString) {
        
        JSStringRef stringAsJSString = JSValueToStringCopy(ctx, value, NULL);
        if (stringAsJSString != NULL) {
            
            CFStringRef string = JSStringCopyCFString(kCFAllocatorDefault, stringAsJSString);
            JSStringRelease(stringAsJSString);
            
            return [NSMakeCollectable(string) autorelease];
        }
    }
    else if (type == kJSTypeObject && JSValueIsObjectOfClass(ctx, value, MRJSWrappedObjectJSClass())) {
        
        JSObjectRef object = (JSObjectRef)value;
        if (object != NULL) {
            return JSObjectGetPrivate(object);
        }
    }
    else if (type == kJSTypeObject && JSObjectGetPrivate((JSObjectRef)value) == nil) {
        
        MRJSContext *context = JSObjectGetPrivate(JSContextGetGlobalObject(ctx));
        if (context != nil) {
            
            JSObjectRef object = (JSObjectRef)value;
            if (JSValueIsEqual(ctx, JSObjectGetPrototype(ctx, object), [context arrayPrototype], NULL)) {
                
                // Standard array
                JSValueRef exception = NULL;
                unsigned int count = (unsigned int)JSValueToNumber(ctx, JSObjectGetProperty(ctx, object, kMRJSPropertyLength, NULL), &exception);
                if (exception != NULL) {
                    return nil;
                }
                
                NSMutableArray *array = [NSMutableArray array];
                for (unsigned int i = 0; i < count; i++) {
                    
                    JSValueRef valueAtIndex = JSObjectGetPropertyAtIndex(ctx, object, i, &exception);
                    if (exception != NULL || valueAtIndex == NULL) {
                        return nil;
                    }
                    
                    id objectAtIndex = MRJSMakeObjectForJSValue(ctx, valueAtIndex, allowsLossyConversion);
                    if (objectAtIndex == nil) {
                        if (allowsLossyConversion) {
                            continue;
                        }
                        else {
                            return nil;
                        }
                    }
                    
                    [array addObject:objectAtIndex];
                }
                
                return array;
                
            }
            else {
                
                // Standard object hash
                JSValueRef exception = NULL;
                JSPropertyNameArrayRef propertyNames = JSObjectCopyPropertyNames(ctx, object);
                size_t propertyNameCount = JSPropertyNameArrayGetCount(propertyNames);
                
                NSMutableDictionary *dictionary = [NSMutableDictionary dictionary];
                for (NSUInteger i = 0; i < propertyNameCount; i++) {
                    
                    JSStringRef propertyName = JSPropertyNameArrayGetNameAtIndex(propertyNames, i);
                    JSValueRef valueForKey = JSObjectGetProperty(ctx, object, propertyName, &exception);
                    if (exception != NULL || valueForKey == NULL) {
                        return nil;
                    }
                    
                    id objectForKey = MRJSMakeObjectForJSValue(ctx, valueForKey, allowsLossyConversion);
                    if (objectForKey == nil) {
                        if (allowsLossyConversion) {
                            continue;
                        }
                        else {
                            return nil;
                        }
                    }
                    
                    CFStringRef propertyNameAsCFString = JSStringCopyCFString(kCFAllocatorDefault, propertyName);
                    [dictionary setObject:objectForKey forKey:(NSString *)propertyNameAsCFString];
                    CFRelease(propertyNameAsCFString);
                }
                
                return dictionary;
            }
        }
    }
    else if (type == kJSTypeBoolean) {
        
        return [NSNumber numberWithBool:JSValueToBoolean(ctx, value)];
    }
    else if (type == kJSTypeNumber) {
        
        return [NSNumber numberWithDouble:JSValueToNumber(ctx, value, NULL)];
    }
    
    return nil;
}

static JSValueRef MRJSMakeJSValueForObject(JSContextRef ctx, id objcObject, JSPropertyAttributes propertyAttributes)
{
    if (objcObject == nil) {
        return NULL;
    }
    
    if ([objcObject isKindOfClass:[NSString class]]) {
        
        JSStringRef string = JSStringCreateWithCFString((CFStringRef)objcObject);
        if (string != NULL) {
            JSValueRef stringValue = JSValueMakeString(ctx, string);
            JSStringRelease(string);
            
            return stringValue;
        }
        
        return NULL;
    }
    else if ([objcObject isKindOfClass:[NSNumber class]]) {
        
        NSNumber *number = objcObject;
        if (MRJSCheckEqualObjCType([number objCType], @encode(BOOL))) {
            return JSValueMakeBoolean(ctx, [number boolValue]);
        }
        else {
            return JSValueMakeNumber(ctx, [number doubleValue]);
        }
    }
    else if ([objcObject isKindOfClass:[NSValue class]]) {
        return NULL;
    }
    else if ([objcObject isKindOfClass:[NSArray class]]) {
        
        JSObjectRef arrayForJS = JSObjectMakeArray(ctx, 0, NULL, NULL);
        unsigned arrayIndex = 0;
        
        for (id object in (NSArray*)objcObject) {
            
            JSValueRef value = MRJSMakeJSValueForObject(ctx, object, propertyAttributes);
            
            if (value != NULL) {
                JSObjectSetPropertyAtIndex(ctx, arrayForJS, arrayIndex, value, NULL);
                arrayIndex++;
            }
        }
        
        return arrayForJS;
    }
    else if ([objcObject isKindOfClass:[NSDictionary class]]) {
        
        JSObjectRef arrayForJS = JSObjectMakeArray(ctx, 0, NULL, NULL);
        
        NSDictionary *dictionary = objcObject;
        [dictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop) {
            
            JSStringRef propertyName = JSStringCreateWithCFString((CFStringRef)key);
            if (propertyName != NULL) {
                
                JSValueRef value = MRJSMakeJSValueForObject(ctx, object, propertyAttributes);
                
                if (value != NULL) {
                    JSObjectSetProperty(ctx, arrayForJS, propertyName, value, propertyAttributes, NULL);
                    JSStringRelease(propertyName);
                }
            }
        }];
        
        return arrayForJS;
    }
    
    JSObjectRef object = JSObjectMake(ctx, MRJSWrappedObjectJSClass(), objcObject);
    if (object != NULL) {
        
#ifndef __clang_analyzer__
        
        // The +1 reference will be balanced when the JSObject finalizes
        [objcObject retain];
        
#endif
        
        return object;
    }
    
    return NULL;
}

static NSError *errorFromJSException(JSContextRef ctx, JSValueRef exception, MRJSContextErrorCode errorCode)
{
    NSMutableDictionary *userInfo = [NSMutableDictionary dictionary];
    userInfo[NSLocalizedDescriptionKey] = NSStringFromJSException(ctx, exception) ?: @"(Unknown error)";
    
    NSString *origin = MRJSGetOriginFromJSException(ctx, exception);
    NSUInteger lineNumber = MRJSGetLineNumberFromJSException(ctx, exception);
    NSString *stackTrace = MRJSGetStackTraceFromJSException(ctx, exception);
    
    if (origin != nil) {
        userInfo[MRJSContextErrorOriginKey] = origin;
    }
    
    if (lineNumber != NSNotFound) {
        userInfo[MRJSContextErrorLineNumberKey] = @(lineNumber);
    }
    
    if (stackTrace.length > 0) {
        userInfo[MRJSContextErrorStackTraceKey] = stackTrace;
    }
    
    return [NSError errorWithDomain:MRJSContextErrorDomain code:errorCode userInfo:userInfo];
}

static NSString *NSStringFromJSException(JSContextRef ctx, JSValueRef exception)
{
    if (ctx == NULL || exception == NULL)
        return nil;
    
    JSStringRef exceptionAsJSString = JSValueToStringCopy(ctx, exception, NULL);
    if (exceptionAsJSString == NULL) {
        return nil;
    }
    
    CFStringRef exceptionAsCFString = JSStringCopyCFString(kCFAllocatorDefault, exceptionAsJSString);
    JSStringRelease(exceptionAsJSString);
    
    return [NSMakeCollectable(exceptionAsCFString) autorelease];
}

static NSUInteger MRJSGetLineNumberFromJSException(JSContextRef ctx, JSValueRef exception)
{
    NSUInteger lineNumber = NSNotFound;
    
    if (ctx != NULL && exception != NULL && JSValueIsObject(ctx, exception)) {
        
        JSObjectRef exceptionObject = (JSObjectRef)exception;
        JSStringRef linePropertyName = JSStringCreateWithUTF8CString("line");
        JSValueRef lineValue = JSObjectGetProperty(ctx, exceptionObject, linePropertyName, NULL);
        
        if (lineValue != NULL) {
            lineNumber = (NSUInteger)JSValueToNumber(ctx, lineValue, NULL);
        }
        
        JSStringRelease(linePropertyName);
    }
    
    return lineNumber;
}

static NSString *MRJSGetOriginFromJSException(JSContextRef ctx, JSValueRef exception)
{
    NSString *origin = nil;
    
    if (ctx != NULL && exception != NULL && JSValueIsObject(ctx, exception)) {
        
        JSObjectRef exceptionObject = (JSObjectRef)exception;
        JSStringRef propertyName = JSStringCreateWithUTF8CString("sourceURL");
        JSValueRef originValue = JSObjectGetProperty(ctx, exceptionObject, propertyName, NULL);
        
        if (originValue != NULL) {
            JSStringRef originAsJSString = JSValueToStringCopy(ctx, originValue, NULL);
            if (originAsJSString != NULL) {
                CFStringRef originAsCFString = JSStringCopyCFString(kCFAllocatorDefault, originAsJSString);
                JSStringRelease(originAsJSString);
                
                origin = [NSMakeCollectable(originAsCFString) autorelease];
            }
        }
        
        JSStringRelease(propertyName);
    }
    
    return origin;
}

static NSString *MRJSGetStackTraceFromJSException(JSContextRef ctx, JSValueRef exception)
{
    /* Concrete example:
     
     sort@[native code]
     makePredicate@JSEvaluateScript:relativeToObjectByEvaluatingScript:options::179:10
     JSEvaluateScript:relativeToObjectByEvaluatingScript:options::1064:29
     JSEvaluateScript:relativeToObjectByEvaluatingScript:options::6643:3
     global code@JSEvaluateScript:relativeToObjectByEvaluatingScript:options::6643:20
     [native code]
     ____require@JSEvaluateScript:relativeToObjectByEvaluatingScript:options::1:410
     JSEvaluateScript:relativeToObjectByEvaluatingScript:options::1:37
     global code@JSEvaluateScript:relativeToObjectByEvaluatingScript:options::171:4
     
     */
    
    NSString *result = nil;
    
    if (ctx != NULL && exception != NULL && JSValueIsObject(ctx, exception)) {
        
        JSObjectRef exceptionObject = (JSObjectRef)exception;
        JSStringRef propertyName = JSStringCreateWithUTF8CString("stack");
        JSValueRef stackValue = JSObjectGetProperty(ctx, exceptionObject, propertyName, NULL);
        
        if (stackValue != NULL) {
            JSStringRef stackAsJSString = JSValueToStringCopy(ctx, stackValue, NULL);
            if (stackAsJSString != NULL) {
                CFStringRef stackAsCFString = JSStringCopyCFString(kCFAllocatorDefault, stackAsJSString);
                JSStringRelease(stackAsJSString);
                
                NSString *stack = [NSMakeCollectable(stackAsCFString) autorelease];
                NSMutableArray<NSString *> *cleanedStackEntries = [NSMutableArray array];
                [stack enumerateLinesUsingBlock:^(NSString *line, BOOL *stop) {
                    
                    NSRange evalRange = [line rangeOfString:@"JSEvaluateScript:options:origin:"];
                    if (evalRange.location != NSNotFound) {
                        [cleanedStackEntries addObject:[NSString stringWithFormat:@"%@[script]%@", [line substringToIndex:evalRange.location], [line substringFromIndex:NSMaxRange(evalRange)]]];
                    }
                    else {
                        [cleanedStackEntries addObject:line];
                    }
                }];
                
                result = [cleanedStackEntries componentsJoinedByString:@"\n"];
            }
        }
        
        JSStringRelease(propertyName);
    }
    
    return result;
}

static JSValueRef MRJSMakeJSException(JSContextRef ctx, NSString *exceptionStringAsNSString)
{
    JSStringRef exceptionString = JSStringCreateWithCFString((CFStringRef)exceptionStringAsNSString);
    JSValueRef exception = JSValueMakeString(ctx, exceptionString);
    JSStringRelease(exceptionString);
    
    return exception;
}

static BOOL MRJSContextMsgSend(JSContextRef ctx, id target, Method method, BOOL expectsReturnValue, size_t argumentCount, const JSValueRef arguments[], id *returnObject, JSValueRef *returnValue, JSValueRef *outException, BOOL allowsLossyArgumentConversion)
{
    if (target == nil || method == NULL) {
        return NO;
    }
    
    // If there are too many arguments, there's not much we can do automatically that makes sense
    size_t maxArgumentCount = method_getNumberOfArguments(method) - 2; // 0 = self, 1 = _cmd
    if (argumentCount > maxArgumentCount || argumentCount > kMRJSMaximumNumberOfArgumentsForFunction) {
        
        if (outException != NULL) {
            (*outException) = MRJSMakeJSException(ctx, [NSString stringWithFormat:@"JSContextError: Too many arguments for method '%@'.", NSStringFromSelector(method_getName(method))]);
        }
        
        return NO;
    }
    
    id msgSendResult = nil;
    if (maxArgumentCount == 0) {
        msgSendResult = ((id (*)(id, SEL))objc_msgSend)(target, method_getName(method));
    }
    else {
        
        id objcArguments[kMRJSMaximumNumberOfArgumentsForFunction] = { nil, nil, nil, nil, nil, nil, nil, nil, nil };
        for (NSUInteger i = 0; i < argumentCount; i++) {
            objcArguments[i] = [[MRJSMakeObjectForJSValue(ctx, arguments[i], allowsLossyArgumentConversion) retain] autorelease];
        }
        
        msgSendResult = ((id (*)(id, SEL, id,id,id,id,id,id,id,id,id))objc_msgSend)(target, method_getName(method),
                                     objcArguments[0], 
                                     objcArguments[1], 
                                     objcArguments[2], 
                                     objcArguments[3], 
                                     objcArguments[4], 
                                     objcArguments[5], 
                                     objcArguments[6], 
                                     objcArguments[7], 
                                     objcArguments[8]);
    }
    
    if (expectsReturnValue) {
        if (returnObject != NULL)
            (*returnObject) = msgSendResult;
        if (returnValue != NULL)
            (*returnValue) = MRJSMakeJSValueForObject(ctx, msgSendResult, kJSPropertyAttributeNone);
    }
    
    return YES;
}

BOOL MRJSMsgSend(id target, Method method, NSArray *arguments, id *returnObject)
{
    if (target == nil || method == NULL) {
        return NO;
    }
    
    // If there are too many arguments, there's not much we can do automatically that makes sense
    size_t argumentCount = arguments.count;
    size_t maxArgumentCount = method_getNumberOfArguments(method) - 2; // 0 = self, 1 = _cmd
    if (argumentCount > maxArgumentCount || argumentCount > kMRJSMaximumNumberOfArgumentsForFunction) {
        NSLog(@"MRJS error: Too many arguments for method '%@'.", NSStringFromSelector(method_getName(method)));
        return NO;
    }
    
    id msgSendResult = nil;
    if (maxArgumentCount == 0) {
        msgSendResult = ((id (*)(id, SEL))objc_msgSend)(target, method_getName(method));
    }
    else {
        
        id objcArguments[kMRJSMaximumNumberOfArgumentsForFunction] = { nil, nil, nil, nil, nil, nil, nil, nil, nil };
        for (NSUInteger i = 0; i < argumentCount; i++) {
            objcArguments[i] = [[arguments[i] retain] autorelease];
        }
        
        msgSendResult = ((id (*)(id, SEL, id,id,id,id,id,id,id,id,id))objc_msgSend)(target, method_getName(method),
                                                                                    objcArguments[0],
                                                                                    objcArguments[1],
                                                                                    objcArguments[2],
                                                                                    objcArguments[3],
                                                                                    objcArguments[4],
                                                                                    objcArguments[5],
                                                                                    objcArguments[6],
                                                                                    objcArguments[7],
                                                                                    objcArguments[8]);
    }
    
    if (returnObject != NULL) {
        if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(id))) {
            (*returnObject) = [[msgSendResult retain] autorelease];
        }
        else if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(BOOL))) {
            (*returnObject) = [NSNumber numberWithBool:(msgSendResult != nil)];
        }
        else {
            (*returnObject) = nil;
        }
    }
    
    return YES;
}

static NSArray *MRJSSelectorModifiersForClass(Class objcClass)
{
    static dispatch_semaphore_t resourceSemaphore = NULL;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        resourceSemaphore = dispatch_semaphore_create(1);
    });
    
    NSArray *modifiers = nil;
    
    dispatch_semaphore_wait(resourceSemaphore, DISPATCH_TIME_FOREVER);
    {
        static NSMapTable *classToModifiersMap = nil;
        if (classToModifiersMap == nil) {
            classToModifiersMap = NEW_OPAQUE_TO_OBJECT_MAP;
        }
        
        modifiers = NSMapGet(classToModifiersMap, objcClass);
        
        if (modifiers == nil) {
            
            NSMutableArray *newModifiers = [[NSMutableArray alloc] initWithObjects:@"", nil];
            
            unsigned int numberOfProtocols = 0;
            Protocol **protocols = class_copyProtocolList(objcClass, &numberOfProtocols);
            for (unsigned int i = 0; i < numberOfProtocols; i ++) {
                NSString *protocolName = NSStringFromProtocol(protocols[i]);
                if (protocolName != nil) {
                    [newModifiers addObject:[NSString stringWithFormat:@"ifConformsTo%@_", protocolName]];
                }
            }
            
            modifiers = newModifiers;
            NSMapInsert(classToModifiersMap, objcClass, modifiers);
            [newModifiers release];
        }
    }
    dispatch_semaphore_signal(resourceSemaphore);
    
    return modifiers;
}

static MRJSConstructor MRJSConstructorBlockForClass(Class objcClass)
{
    static dispatch_semaphore_t resourceSemaphore = NULL;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        resourceSemaphore = dispatch_semaphore_create(1);
    });
    
    MRJSConstructor constructor = nil;
    
    dispatch_semaphore_wait(resourceSemaphore, DISPATCH_TIME_FOREVER);
    {
        static MRJSConstructor nullConstructor = nil;
        static NSMapTable *classToConstructorMap = nil;
        if (classToConstructorMap == nil) {
            classToConstructorMap = NEW_OPAQUE_TO_OBJECT_MAP;
            nullConstructor = (MRJSConstructor)[[NSNull null] retain];
        }
        
        constructor = NSMapGet(classToConstructorMap, objcClass);
        if (constructor == nil) {
            
            NSMutableArray *possibleSelectorStrings = [[NSMutableArray alloc] init];
            for (NSUInteger i = 0; i < kMRJSMaximumNumberOfArgumentsForFunction; i++) {
                
                if (possibleSelectorStrings.count == 0)
                    [possibleSelectorStrings insertObject:@"new_jsconstructor:" atIndex:0];
                else
                    [possibleSelectorStrings insertObject:[[possibleSelectorStrings objectAtIndex:0] stringByAppendingString:@":"] atIndex:0];
            }
            
            for (NSString *selectorString in possibleSelectorStrings) {
                
                if (constructor != nil)
                    break;
                
                Method constructorMethod = class_getClassMethod(objcClass, NSSelectorFromString(selectorString));
                if (constructorMethod != NULL) {
                    
                    constructor = ^(JSContextRef ctx, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException) {
                        
                        id returnValue = nil;
                        MRJSContextMsgSend(ctx, objcClass, constructorMethod, YES, argumentCount, arguments, &returnValue, NULL, outException, NO);
                        return returnValue;
                    };
                }
            }
            
            constructor = [constructor copy];
            NSMapInsert(classToConstructorMap, objcClass, constructor ?: nullConstructor);
            [constructor release];
        }
        else if (constructor == nullConstructor) {
            constructor = nil;
        }
    }
    dispatch_semaphore_signal(resourceSemaphore);

    return constructor;
}

static NSString *MRJSCapitalizedPropertyName(NSString *propertyName)
{
    if (propertyName.length == 0)
        return propertyName;
    return [[[propertyName substringToIndex:1] uppercaseString] stringByAppendingString:[propertyName substringFromIndex:1]];
}

#pragma mark -

- (void)addConstructorForClass:(Class)objcClass withName:(NSString *)jsClassName
{
    if (jsClassName.length == 0)
        jsClassName = NSStringFromClass(objcClass);
    
    if (objcClass == nil)
        return;
    
    if (MRJSConstructorBlockForClass(objcClass) != nil) {
        NSMapInsert(classNameToConstructorObjectClassMap_, jsClassName, objcClass);
    }
    else {
        [NSException raise:NSInvalidArgumentException format:@"Class '%@' doesn't implement +new_jsconstructor:", NSStringFromClass(objcClass)];
    }
}

- (void)addConstant:(id)objcValue withName:(NSString *)constantName
{
    if (objcValue == nil || constantName.length == 0)
        return;
    
    JSValueRef value = MRJSMakeJSValueForObject(ctx_, objcValue, kJSPropertyAttributeNone);
    if (value != NULL) {
        [self setJSValue:value forGlobalProperty:constantName];
    }
}

- (void)addIncludeFunctionWithName:(NSString *)functionName block:(NSString * (^)(NSString *includeName))block
{
    static JSClassRef functionClassForWrappedIncludeBlock;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        
        JSClassDefinition definition = kJSClassDefinitionEmpty;
        definition.className = "MRJSIncludeBlockFunction";
        definition.finalize = MRJSContextIncludeBlockFinalize;
        definition.callAsFunction = MRJSContextIncludeBlockCallAsFunction;
        functionClassForWrappedIncludeBlock = JSClassCreate(&definition);
    });
    
    if (functionName.length == 0) {
        [NSException raise:NSInvalidArgumentException format:@"%@ -- function name must not be empty", NSStringFromSelector(_cmd)];
        return;
    }
    
    if (block == nil) {
        [NSException raise:NSInvalidArgumentException format:@"%@ -- function block is nil", NSStringFromSelector(_cmd)];
        return;
    }
    
#ifndef __clang_analyzer__
    block = [block copy];
#endif
    
    JSObjectRef function = JSObjectMake(ctx_, functionClassForWrappedIncludeBlock, block);
    if (function != NULL) {
        [self setJSValue:function forGlobalProperty:functionName];
    }
}

- (JSValueRef)JSEvaluateScript:(NSString *)scriptNSString options:(MRJSScriptOptions)options origin:(NSString *)originNSString
{
    if (scriptNSString == nil)
        return NULL;
    
    JSStringRef script = JSStringCreateWithCFString((CFStringRef)scriptNSString);
    JSStringRef origin = JSStringCreateWithCFString((CFStringRef)(originNSString ?: NSStringFromSelector(_cmd)));
    
    BOOL canSetGlobalProperties = (options & MRJSScriptCanSetGlobalProperties) != 0;
    if (canSetGlobalProperties) {
        canSetGlobalPropertiesOverride_++;
    }
    
    JSValueRef exception = NULL;
    JSValueRef result = JSEvaluateScript(ctx_, script, NULL, origin, 1, &exception);
    
    if (canSetGlobalProperties) {
        canSetGlobalPropertiesOverride_--;
    }
    
    if (script != NULL)
        JSStringRelease(script);
    if (origin != NULL)
        JSStringRelease(origin);
    
    if (exception != NULL) {
        [console_ logException:errorFromJSException(ctx_, exception, MRJSContextEvaluationError)];
    }
    
    return result;
}

- (void)evaluateScript:(NSString *)scriptNSString options:(MRJSScriptOptions)options origin:(NSString *)origin
{
    [self JSEvaluateScript:scriptNSString options:options origin:origin];
}

- (void)setValue:(id)objcValue forProperty:(NSString *)propertyNSString ofObjectByEvaluatingScript:(NSString *)scriptNSString options:(MRJSScriptOptions)options
{
    JSPropertyAttributes propertyAttributes = kJSPropertyAttributeNone;
    if ((options & MRJSScriptSetPropertyReadOnly) != 0)
        propertyAttributes |= kJSPropertyAttributeReadOnly;
    if ((options & MRJSScriptSetPropertyDontDelete) != 0)
        propertyAttributes |= kJSPropertyAttributeDontDelete;
    
    JSStringRef script = JSStringCreateWithCFString((CFStringRef)scriptNSString);
    if (script != NULL) {
        
        JSValueRef result = JSEvaluateScript(ctx_, script, NULL, NULL, 0, NULL);
        if (result != NULL && JSValueIsObject(ctx_, result)) {
            
            JSStringRef propertyName = JSStringCreateWithCFString((CFStringRef)propertyNSString);
            if (propertyName != NULL) {
                
                JSValueRef value = MRJSMakeJSValueForObject(ctx_, objcValue, propertyAttributes);
                if (value == NULL)
                    value = JSValueMakeNull(ctx_);
                
                JSObjectSetProperty(ctx_, (JSObjectRef)result, propertyName, value, propertyAttributes, NULL);
                JSStringRelease(propertyName);
            }
        }
        
        JSStringRelease(script);
    }
}

- (MRJSFunctionBlock)copyFunctionByEvaluatingScript:(NSString *)scriptString argumentCount:(NSUInteger)neededArgumentCount error:(NSError **)outParserError
{
    if (scriptString.length == 0) {
        return nil;
    }
    
    JSStringRef script = JSStringCreateWithCFString((CFStringRef)scriptString);
    JSStringRef origin = JSStringCreateWithCFString((CFStringRef)NSStringFromSelector(_cmd));
    
    JSValueRef evaluateException = NULL;
    JSValueRef evaluateResult = JSEvaluateScript(ctx_, script, NULL, origin, 1, &evaluateException);
    
    JSStringRelease(script);
    JSStringRelease(origin);
    
    if (evaluateException != NULL) {
        if (outParserError != NULL) {
            (*outParserError) = errorFromJSException(ctx_, evaluateException, MRJSContextParserError);
        }
        
        return nil;
    }
    
    if (evaluateResult != NULL && JSValueIsObject(ctx_, evaluateResult) && JSObjectIsFunction(ctx_, (JSObjectRef)evaluateResult)) {
        
        // FIXME: function should get JSValueProtect while the block lives. this can be done by making an obj-c object that protects/unprotects on init/dealloc, and referencing it in the block. need to find a way to force the garbage collector so the function is killed, so this protection can be tested
        
        JSObjectRef function = (JSObjectRef)evaluateResult;
        //JSGarbageCollect(ctx_);
        
        JSValueRef argumentCountValue = JSObjectGetProperty(ctx_, function, kMRJSPropertyLength, NULL);
        NSUInteger argumentCount = (argumentCountValue == NULL) ? 0 : MRJSValueToUInteger(ctx_, argumentCountValue, NULL);
        
        if (argumentCount < neededArgumentCount) {
            
            // Not enough arguments to support the wanted function
            return nil;
        }
        
        id (^functionCaller)(NSUInteger, id[], NSError **) = ^(NSUInteger argCount, id objcArgs[], NSError **outRuntimeError) {
            
            JSValueRef args[argCount];
            for (NSUInteger i = 0; i < argCount; i++) {
                args[i] = MRJSMakeJSValueForObject(ctx_, objcArgs[i], kJSPropertyAttributeNone);
            }
            
            JSValueRef exceptionValue = NULL;
            JSValueRef result = JSObjectCallAsFunction(ctx_, function, NULL, argCount, args, &exceptionValue);
            
            if (exceptionValue != NULL) {
                
                NSError *error = errorFromJSException(ctx_, exceptionValue, MRJSContextRuntimeError);
                [console_ logException:error];
                
                if (outRuntimeError != NULL) {
                    (*outRuntimeError) = error;
                }
            }
            
            return MRJSMakeObjectForJSValue(ctx_, result, NO);
        };
        
        if (neededArgumentCount == 0) {
            return [^(NSError **outRuntimeError) { return functionCaller(0, NULL, outRuntimeError); } copy];
        }
        else if (neededArgumentCount == 1) {
            return [^(id arg1, NSError **outRuntimeError) { return functionCaller(1, (id[]){ arg1 }, outRuntimeError); } copy];
        }
        else if (neededArgumentCount == 2) {
            return [^(id arg1, id arg2, NSError **outRuntimeError) { return functionCaller(2, (id[]){ arg1, arg2 }, outRuntimeError); } copy];
        }
        else if (neededArgumentCount == 3) {
            return [^(id arg1, id arg2, id arg3, NSError **outRuntimeError) { return functionCaller(3, (id[]){ arg1, arg2, arg3 }, outRuntimeError); } copy];
        }
        else if (neededArgumentCount == 4) {
            return [^(id arg1, id arg2, id arg3, id arg4, NSError **outRuntimeError) { return functionCaller(4, (id[]){ arg1, arg2, arg3, arg4 }, outRuntimeError); } copy];
        }
        else if (neededArgumentCount == 5) {
            return [^(id arg1, id arg2, id arg3, id arg4, id arg5, NSError **outRuntimeError) { return functionCaller(5, (id[]){ arg1, arg2, arg3, arg4, arg5 }, outRuntimeError); } copy];
        }
    }
    else {
        //NSLog(@"functionByEvaluatingScript failed: %@", MRJSMakeErrorForJSException(ctx_, evaluateException));
    }
    
    return nil;
}

#pragma mark -

- (BOOL)shouldSetGlobalProperty
{
    return canSetGlobalProperties_ || (canSetGlobalPropertiesOverride_ > 0);
}

- (JSValueRef)JSValueForGlobalProperty:(NSString *)propertyName
{
    static JSClassRef classConstructorClass;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        
        JSClassDefinition definition = kJSClassDefinitionEmpty;
        definition.className = "MRJSClassConstructor";
        definition.callAsConstructor = MRJSWrappedClassCallAsConstructor;
        
        classConstructorClass = JSClassCreate(&definition);
    });
    
    
    
    JSValueRef value = NSMapGet(globalPropertyToConstantJSValueMap_, propertyName);
    if (value != NULL) {
        return (value == nullToken) ? NULL : value;
    }
    else {
        
        Class objcClass = NSMapGet(classNameToConstructorObjectClassMap_, propertyName);
        if (objcClass != Nil) {
            
            JSObjectRef classObject = JSObjectMake(ctx_, classConstructorClass, objcClass);
            value = classObject;
        }
    }
    
    if (value != NULL)
        [self _protectValue:value];

    NSMapInsert(globalPropertyToConstantJSValueMap_, propertyName, value ?: nullToken);
    
    return value;
}

- (JSValueRef)JSValueForProperty:(NSString *)propertyName ofObject:(id)objcObject
{
    static JSClassRef functionClassForWrappedMethodVoid;
    static JSClassRef functionClassForWrappedMethodVoid_allowsLossyArgumentConversion;
    static JSClassRef functionClassForWrappedMethodId;
    static JSClassRef functionClassForWrappedMethodId_allowsLossyArgumentConversion;
    static JSClassRef functionClassForWrappedMethodBOOL;
    static JSClassRef functionClassForWrappedMethodBOOL_allowsLossyArgumentConversion;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        
        JSClassDefinition definition = kJSClassDefinitionEmpty;
        definition.className = "MRJSMethodFunction";
        
        definition.callAsFunction = MRJSWrappedMethodCallAsFunctionVoid;
        functionClassForWrappedMethodVoid = JSClassCreate(&definition);
        
        definition.callAsFunction = MRJSWrappedMethodCallAsFunctionVoid_allowsLossyArgumentConversion;
        functionClassForWrappedMethodVoid_allowsLossyArgumentConversion = JSClassCreate(&definition);
        
        definition.callAsFunction = MRJSWrappedMethodCallAsFunctionId;
        functionClassForWrappedMethodId = JSClassCreate(&definition);
        
        definition.callAsFunction = MRJSWrappedMethodCallAsFunctionId_allowsLossyArgumentConversion;
        functionClassForWrappedMethodId_allowsLossyArgumentConversion = JSClassCreate(&definition);
        
        definition.callAsFunction = MRJSWrappedMethodCallAsFunctionBOOL;
        functionClassForWrappedMethodBOOL = JSClassCreate(&definition);
        
        definition.callAsFunction = MRJSWrappedMethodCallAsFunctionBOOL_allowsLossyArgumentConversion;
        functionClassForWrappedMethodBOOL_allowsLossyArgumentConversion = JSClassCreate(&definition);
    });
    
    
    
    Class objcClass = [objcObject class];
    if (propertyName == nil || objcClass == Nil)
        return NULL;
    
    NSArray *selectorModifiers = MRJSSelectorModifiersForClass(objcClass);
    
    // Objective-C property implemented with - (id)js_propertyName;
    {
        NSMapTable *propertyNameToObjectGetterMap_ = NSMapGet(classToPropertyNameToObjectGetterMap_, objcClass);
        if (propertyNameToObjectGetterMap_ == nil) {
            propertyNameToObjectGetterMap_ = NEW_OBJECT_TO_OPAQUE_MAP;
            NSMapInsert(classToPropertyNameToObjectGetterMap_, objcClass, propertyNameToObjectGetterMap_);
            [propertyNameToObjectGetterMap_ release];
        }
        
        SEL getterSelector = NSMapGet(propertyNameToObjectGetterMap_, propertyName);
        if (getterSelector == NULL) {
            
            for (NSString *modifier in selectorModifiers) {
                
                if (getterSelector != NULL)
                    break;
                
                SEL selector = NSSelectorFromString([NSString stringWithFormat:@"js_%@%@", modifier, propertyName]);
                Method method = class_getInstanceMethod(objcClass, selector);
                if (method != NULL) {
                    
                    if (method_getNumberOfArguments(method) == 2 && MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(id))) {
                        getterSelector = selector;
                    }
                }
            }
            
            NSMapInsert(propertyNameToObjectGetterMap_, propertyName, getterSelector ?: nullSelector);
        }
        
        if (getterSelector != NULL && getterSelector != nullSelector) {
            return MRJSMakeJSValueForObject(ctx_, ((id (*)(id, SEL))objc_msgSend)(objcObject, getterSelector), kJSPropertyAttributeNone);
        }
    }
    
    // Advanced property implemented with - (JSValueRef)jsvalue_propertyName:(JSContextRef)ctx;
    {
        NSMapTable *propertyNameToJSValueGetterMap = NSMapGet(classToPropertyNameToJSValueGetterMap_, objcClass);
        if (propertyNameToJSValueGetterMap == nil) {
            propertyNameToJSValueGetterMap = NEW_OBJECT_TO_OPAQUE_MAP;
            NSMapInsert(classToPropertyNameToJSValueGetterMap_, objcClass, propertyNameToJSValueGetterMap);
            [propertyNameToJSValueGetterMap release];
        }
        
        SEL getterSelector = NSMapGet(propertyNameToJSValueGetterMap, propertyName);
        if (getterSelector == NULL) {
            
            for (NSString *modifier in selectorModifiers) {
                
                if (getterSelector != NULL)
                    break;
                
                SEL selector = NSSelectorFromString([NSString stringWithFormat:@"jsvalue_%@%@:", modifier, propertyName]);
                Method method = class_getInstanceMethod(objcClass, selector);
                if (method != NULL)  {
                    
                    if (method_getNumberOfArguments(method) == 3) { // 0 = self, 1 = _cmd, 2 = context
                        if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(JSValueRef))) {
                            if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyArgumentType(method, 2), @encode(JSContextRef))) {
                                getterSelector = selector;
                            }
                        }
                    }
                }
            }
            
            NSMapInsert(propertyNameToJSValueGetterMap, propertyName, getterSelector ?: nullSelector);
        }
        
        if (getterSelector != NULL && getterSelector != nullSelector) {
            return ((JSValueRef (*)(id, SEL, JSContextRef))objc_msgSend)(objcObject, getterSelector, ctx_);
        }
    }
    
    // Function implemented with - (void|id)js_propertyName:(id)arg :(id)arg2 ...;
    {
        NSMapTable *functionNameToJSFunctionMap = NSMapGet(classToFunctionNameToJSFunctionMap_, objcClass);
        if (functionNameToJSFunctionMap == nil) {
            functionNameToJSFunctionMap = NEW_OBJECT_TO_OPAQUE_MAP;
            NSMapInsert(classToFunctionNameToJSFunctionMap_, objcClass, functionNameToJSFunctionMap);
            [functionNameToJSFunctionMap release];
        }
        
        JSObjectRef function = NSMapGet(functionNameToJSFunctionMap, propertyName);
        if (function == nullToken) {
            function = NULL;
        }
        else if (function == NULL) {
            
            BOOL isSetterFunction = ([propertyName hasPrefix:@"set"] && propertyName.length >= 4);
            if (isSetterFunction) {
                NSString *nextCharacter = [propertyName substringWithRange:NSMakeRange(3, 1)];
                isSetterFunction &= [nextCharacter isEqualToString:[nextCharacter uppercaseString]];
            }
            
            if (!isSetterFunction) {
                
                NSMutableArray *possibleSelectorStrings = [[NSMutableArray alloc] init];
                NSString *allowsLossyArgumentConversionToken = @"_allowsLossyArgumentConversion";
                
                for (NSString *modifier in selectorModifiers) {
                    
                    NSUInteger insertionIndex = possibleSelectorStrings.count;
                    NSString *selectorString = [NSString stringWithFormat:@"js_%@%@", modifier, propertyName];
                    NSString *partiallyConvertedArgumentsSelectorString = [NSString stringWithFormat:@"js%@_%@%@", allowsLossyArgumentConversionToken, modifier, propertyName];
                    for (NSUInteger i = 0; i < kMRJSMaximumNumberOfArgumentsForFunction; i++) {
                        
                        selectorString = [selectorString stringByAppendingString:@":"];
                        [possibleSelectorStrings insertObject:selectorString atIndex:insertionIndex];
                        
                        partiallyConvertedArgumentsSelectorString = [partiallyConvertedArgumentsSelectorString stringByAppendingString:@":"];
                        [possibleSelectorStrings insertObject:partiallyConvertedArgumentsSelectorString atIndex:insertionIndex];
                    }
                }
                
                for (NSString *selectorString in possibleSelectorStrings) {
                    
                    if (function != NULL)
                        break;
                    
                    Method method = class_getInstanceMethod(objcClass, NSSelectorFromString(selectorString));
                    if (method != NULL) {
                        
                        // Make sure every argument is expecting an (id) type, or things will go horribly wrong
                        BOOL hasProblematicArguments = NO;
                        unsigned int argCount = method_getNumberOfArguments(method) - 2; // 0 = self, 1 = _cmd
                        for (unsigned int i = 0; i < argCount && !hasProblematicArguments; i++) {
                            hasProblematicArguments |= !MRJSCheckEqualAndFreeCopiedObjCType(method_copyArgumentType(method, 2+i), @encode(id));
                        }
                        
                        if (!hasProblematicArguments) {
                            
                            BOOL allowsLossyArgumentConversion = [selectorString rangeOfString:allowsLossyArgumentConversionToken].location != NSNotFound;
                            
                            if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(void))) {
                                function = JSObjectMake(ctx_, allowsLossyArgumentConversion ? functionClassForWrappedMethodVoid_allowsLossyArgumentConversion : functionClassForWrappedMethodVoid, method);
                            }
                            else if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(id))) {
                                function = JSObjectMake(ctx_, allowsLossyArgumentConversion ? functionClassForWrappedMethodId_allowsLossyArgumentConversion : functionClassForWrappedMethodId, method);
                            }
                            else if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(BOOL))) {
                                function = JSObjectMake(ctx_, allowsLossyArgumentConversion ? functionClassForWrappedMethodBOOL_allowsLossyArgumentConversion : functionClassForWrappedMethodBOOL, method);
                            }
                        }
                    }
                }
                
                [possibleSelectorStrings release];
            }
            
            if (function != NULL) {
                [self _protectValue:function];
                NSMapInsert(functionNameToJSFunctionMap, propertyName, function);
            }
            else {
                NSMapInsert(functionNameToJSFunctionMap, propertyName, nullToken);
            }
        }
        
        return function;
    }
    
    return NULL;
}

- (BOOL)setJSValue:(JSValueRef)value forProperty:(NSString *)propertyName ofObject:(id)objcObject
{
    if (propertyName == nil)
        return NO;
    
    Class objcClass = [objcObject class];
    if (objcClass == Nil)
        return NO;
    
    NSArray *selectorModifiers = MRJSSelectorModifiersForClass(objcClass);
    
    // Objective-C property setter implemented with - (BOOL)js_setPropertyName:(id)value;
    {
        NSMapTable *propertyNameToObjectSetterMap = NSMapGet(classToPropertyNameToObjectSetterMap_, objcClass);
        if (propertyNameToObjectSetterMap == nil) {
            propertyNameToObjectSetterMap = NEW_OBJECT_TO_OPAQUE_MAP;
            NSMapInsert(classToPropertyNameToObjectSetterMap_, objcClass, propertyNameToObjectSetterMap);
            [propertyNameToObjectSetterMap release];
        }
        
        SEL setterSelector = NSMapGet(propertyNameToObjectSetterMap, propertyName);
        if (setterSelector == NULL) {
            
            for (NSString *modifier in selectorModifiers) {
                
                if (setterSelector != NULL)
                    break;
                
                SEL selector = NSSelectorFromString([NSString stringWithFormat:@"js_%@set%@:", modifier, MRJSCapitalizedPropertyName(propertyName)]);
                Method method = class_getInstanceMethod(objcClass, selector);
                if (method != NULL) {
                    if (method_getNumberOfArguments(method) == 3) { // 0 = self, 1 = _cmd, 2 = value
                        if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(BOOL))) {
                            if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyArgumentType(method, 2), @encode(id))) {
                                setterSelector = selector;
                            }
                        }
                    }
                }
            }
            
            NSMapInsert(propertyNameToObjectSetterMap, propertyName, setterSelector ?: nullSelector);
        }
        
        if (setterSelector != NULL && setterSelector != nullSelector) {
            return ((BOOL (*)(id, SEL, id))objc_msgSend)(objcObject, setterSelector, MRJSMakeObjectForJSValue(ctx_, value, NO));
        }
    }
    
    // Advanced property setter implemented with - (BOOL)js_setPropertyName:(JSValueRef)value withJSContext:(JSContextRef)ctx;
    {
        NSMapTable *propertyNameToJSValueSetterMap = NSMapGet(classToPropertyNameToJSValueSetterMap_, objcClass);
        if (propertyNameToJSValueSetterMap == nil) {
            propertyNameToJSValueSetterMap = NEW_OBJECT_TO_OPAQUE_MAP;
            NSMapInsert(classToPropertyNameToJSValueSetterMap_, objcClass, propertyNameToJSValueSetterMap);
            [propertyNameToJSValueSetterMap release];
        }
        
        SEL setterSelector = NSMapGet(propertyNameToJSValueSetterMap, propertyName);
        if (setterSelector == NULL) {
            
            for (NSString *modifier in selectorModifiers) {
                
                if (setterSelector != NULL)
                    break;
                
                SEL selector = NSSelectorFromString([NSString stringWithFormat:@"jsvalue_%@set%@:context:", modifier, MRJSCapitalizedPropertyName(propertyName)]);
                Method method = class_getInstanceMethod(objcClass, selector);
                if (method != NULL) {
                    
                    if (method_getNumberOfArguments(method) == 4) { // 0 = self, 1 = _cmd, 2 = value, 3 = context
                        if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyReturnType(method), @encode(BOOL))) {
                            if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyArgumentType(method, 2), @encode(JSValueRef))) {
                                if (MRJSCheckEqualAndFreeCopiedObjCType(method_copyArgumentType(method, 3), @encode(JSContextRef))) {
                                    setterSelector = selector;
                                }
                            }
                        }
                    }
                }
            }
            
            NSMapInsert(propertyNameToJSValueSetterMap, propertyName, setterSelector ?: nullSelector);
        }
        
        if (setterSelector != NULL && setterSelector != nullSelector) {
            return ((BOOL (*)(id, SEL, JSValueRef, JSContextRef))objc_msgSend)(objcObject, setterSelector, value, ctx_);
        }
    }
    
    return NO;
}

@end


#pragma mark -


JSValueRef MRJSContextGlobalGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef *outException)
{
    MRJSContext *context = JSObjectGetPrivate(JSContextGetGlobalObject(ctx));
    
    CFStringRef propertyNameAsCFString = JSStringCopyCFString(kCFAllocatorDefault, propertyName);
    if (propertyNameAsCFString != nil) {
        
        JSValueRef value = [context JSValueForGlobalProperty:(NSString *)propertyNameAsCFString];
        CFRelease(propertyNameAsCFString);
        return value;
    }
    
    return NULL;
}

bool MRJSContextGlobalSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef *outException)
{
    MRJSContext *context = JSObjectGetPrivate(JSContextGetGlobalObject(ctx));
    
    if ([context shouldSetGlobalProperty]) {
        
        // Returning false means that the default class will write the value
        return false;
    }
    
    if (outException != NULL) {
        
        CFStringRef propertyNameAsCFString = JSStringCopyCFString(kCFAllocatorDefault, propertyName);
        
        (*outException) = MRJSMakeJSException(ctx, [NSString stringWithFormat:@"JSContextError: Global context is read-only; cannot set global property '%@'. Declare your variables with 'var'.", (NSString *)propertyNameAsCFString]);
        
        if (propertyNameAsCFString != nil) {
            CFRelease(propertyNameAsCFString);
        }
    }
    
    return true;
}

JSValueRef MRJSContextIncludeBlockCallAsFunction(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    if ((argumentCount != 1 && argumentCount != 2) || !JSValueIsString(ctx, arguments[0]))
        return JSValueMakeUndefined(ctx);
    
    MRJSContext *context = JSObjectGetPrivate(JSContextGetGlobalObject(ctx));
    NSString * (^includeBlock)(NSString *includeName) = JSObjectGetPrivate(function);
    NSString *script = includeBlock(MRJSMakeObjectForJSValue(ctx, arguments[0], NO));
    
    return [context JSEvaluateScript:script options:0 origin:nil] ?: JSValueMakeUndefined(ctx);
}

void MRJSContextIncludeBlockFinalize(JSObjectRef object)
{
    MRJSWrappedObjectFinalize(object);
}

JSObjectRef MRJSWrappedClassCallAsConstructor(JSContextRef ctx, JSObjectRef constructor, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    Class objcClass = JSObjectGetPrivate(constructor);
    if (objcClass != Nil) {
        
#ifndef __clang_analyzer__
        
        // The +1 reference will be balanced when the JSObject finalizes
        MRJSConstructor constructorBlock = MRJSConstructorBlockForClass(objcClass);
        if (constructorBlock != nil) {
            
            id objcObject = constructorBlock(ctx, argumentCount, arguments, outException);
            JSObjectRef object = JSObjectMake(ctx, MRJSWrappedObjectJSClass(), objcObject);
            if (object == NULL) {
                [objcObject release];
            }
            else {
                return object;
            }
        }
        
#endif
        
    }
    
    if (outException != NULL) {
        (*outException) = MRJSMakeJSException(ctx, @"JSContextError: Calling unknown constructor.");
    }
    
    // Returning NULL is not allowed, crashes
    return JSObjectMakeArray(ctx, 0, NULL, NULL);
}

JSValueRef MRJSWrappedObjectGetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef *exception)
{
    MRJSContext *context = JSObjectGetPrivate(JSContextGetGlobalObject(ctx));
    id objcObject = (id)JSObjectGetPrivate(object);
    
    CFStringRef propertyNameAsNSString = JSStringCopyCFString(kCFAllocatorDefault, propertyName);
    JSValueRef value = [context JSValueForProperty:(NSString *)propertyNameAsNSString ofObject:objcObject];
    CFRelease(propertyNameAsNSString);
    
    return value;
}

bool MRJSWrappedObjectSetProperty(JSContextRef ctx, JSObjectRef object, JSStringRef propertyName, JSValueRef value, JSValueRef *exception)
{
    MRJSContext *context = JSObjectGetPrivate(JSContextGetGlobalObject(ctx));
    id objcObject = (id)JSObjectGetPrivate(object);
    
    CFStringRef propertyNameAsNSString = JSStringCopyCFString(kCFAllocatorDefault, propertyName);
    BOOL didSetProperty = [context setJSValue:value forProperty:(NSString *)propertyNameAsNSString ofObject:objcObject];
    CFRelease(propertyNameAsNSString);
    
    return didSetProperty;
}

void MRJSWrappedObjectFinalize(JSObjectRef object)
{
    id objcObject = (id)JSObjectGetPrivate(object);
    if (objcObject != nil) {
        
        JSObjectSetPrivate(object, nil);
        
        // Balance the +1 from MRJSWrappedClassCallAsConstructor or JSValueForObject:withJSContext:
        [objcObject release];
    }
}

NS_INLINE JSValueRef MRJSWrappedMethodCallAsFunctionVoid_concrete(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException, BOOL allowsLossyArgumentConversion)
{
    id target = JSObjectGetPrivate(thisObject);
    Method method = JSObjectGetPrivate(function);
    MRJSContextMsgSend(ctx, target, method, NO, argumentCount, arguments, NULL, NULL, outException, allowsLossyArgumentConversion);
    return JSValueMakeUndefined(ctx);
}

JSValueRef MRJSWrappedMethodCallAsFunctionVoid(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    return MRJSWrappedMethodCallAsFunctionVoid_concrete(ctx, function, thisObject, argumentCount, arguments, outException, NO);
}

JSValueRef MRJSWrappedMethodCallAsFunctionVoid_allowsLossyArgumentConversion(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    return MRJSWrappedMethodCallAsFunctionVoid_concrete(ctx, function, thisObject, argumentCount, arguments, outException, YES);
}

NS_INLINE JSValueRef MRJSWrappedMethodCallAsFunctionId_concrete(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException, BOOL allowsLossyArgumentConversion)
{
    id target = JSObjectGetPrivate(thisObject);
    Method method = JSObjectGetPrivate(function);
    
    JSValueRef returnValue = NULL;
    BOOL didSend = MRJSContextMsgSend(ctx, target, method, YES, argumentCount, arguments, NULL, &returnValue, outException, allowsLossyArgumentConversion);
    
    if (returnValue != NULL)
        return returnValue;
    else if (didSend)
        return JSValueMakeNull(ctx);
    return JSValueMakeUndefined(ctx);
}

JSValueRef MRJSWrappedMethodCallAsFunctionId(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    return MRJSWrappedMethodCallAsFunctionId_concrete(ctx, function, thisObject, argumentCount, arguments, outException, NO);
}

JSValueRef MRJSWrappedMethodCallAsFunctionId_allowsLossyArgumentConversion(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    return MRJSWrappedMethodCallAsFunctionId_concrete(ctx, function, thisObject, argumentCount, arguments, outException, YES);
}

NS_INLINE JSValueRef MRJSWrappedMethodCallAsFunctionBOOL_concrete(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException, BOOL allowsLossyArgumentConversion)
{
    id target = JSObjectGetPrivate(thisObject);
    Method method = JSObjectGetPrivate(function);
    
    id returnValueWhichIsBool = NULL;
    MRJSContextMsgSend(ctx, target, method, YES, argumentCount, arguments, &returnValueWhichIsBool, NULL, outException, allowsLossyArgumentConversion);
    return JSValueMakeBoolean(ctx, (returnValueWhichIsBool != NULL));
}

JSValueRef MRJSWrappedMethodCallAsFunctionBOOL(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    return MRJSWrappedMethodCallAsFunctionBOOL_concrete(ctx, function, thisObject, argumentCount, arguments, outException, NO);
}

JSValueRef MRJSWrappedMethodCallAsFunctionBOOL_allowsLossyArgumentConversion(JSContextRef ctx, JSObjectRef function, JSObjectRef thisObject, size_t argumentCount, const JSValueRef arguments[], JSValueRef *outException)
{
    return MRJSWrappedMethodCallAsFunctionBOOL_concrete(ctx, function, thisObject, argumentCount, arguments, outException, YES);
}
