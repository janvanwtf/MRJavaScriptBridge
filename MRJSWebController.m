/*
 * Author: Jan Van Boghout <github@janvan.wtf>
 *
 * Copyright (c) 2016-2018 MacRabbit.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use,
 * reproduce, display, distribute, execute, and transmit the
 * Software, and to prepare derivative works of the Software, and
 * to permit third-parties to whom the Software is furnished to do
 * so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement,
 * including the above license grant, this restriction and the
 * following disclaimer, must be included in all copies of the
 * Software, in whole or in part, and all derivative works of the
 * Software, unless such copies or derivative works are solely in
 * the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#import "MRFoundation.h"
#import "MRJSWebController.h"
#import "MRJSContext-Private.h"
#import <objc/objc-class.h>


@implementation MRJSWebPromise
{
    MRLockRef _lock;
    void(^_onResult)(__nullable id value);
    BOOL _hasResult;
    id _resultValue;
}

- (instancetype)init
{
    self = [super init];
    if (self == nil) {
        return nil;
    }
    
    _lock = MRLockCreate();
    
    return self;
}

- (void)dealloc
{
    MRDeallocLock(_lock);
}

- (void)fulfill:(id)value
{
    MRLock(_lock);
    _hasResult = YES;
    _resultValue = value;
    MRUnlock(_lock);
    
    [self _finishIfNeeded];
}

- (void)_onFulfill:(void(^)(__nullable id value))block
{
    block = [block copy];
    
    MRLock(_lock);
    _onResult = block;
    MRUnlock(_lock);
    
    [self _finishIfNeeded];
}

- (void)_finishIfNeeded
{
    typeof(_resultValue) result = nil;
    typeof(_onResult) onResult = nil;
    
    MRLock(_lock);
    if (_hasResult) {
        result = _resultValue;
        onResult = [_onResult copy];
        _onResult = nil;
    }
    MRUnlock(_lock);
    
    if (onResult != nil) {
        onResult(result);
    }
}

@end


typedef void(^MRJSWebControllerMsgSendReply)(id result);
typedef void(^MRJSWebControllerFunctionImplementationBlock)(id target, NSArray *, MRJSWebControllerMsgSendReply reply);


@implementation MRJSWebControllerConfiguration
{
    NSInteger _jsPtrCounter;
    NSMutableDictionary<NSString *, NSDictionary *> *_constantNameToInitialMap;
    NSMapTable<Class, NSDictionary<NSString *, MRJSWebControllerFunctionImplementationBlock> *> *_functionImplementationMap;
}

+ (NSDictionary<NSString *, Class> *)typesForConstants:(NSDictionary<NSString *, NSObject *> *)constants
{
    NSMutableDictionary<NSString *,Class> *types = [NSMutableDictionary new];
    [constants enumerateKeysAndObjectsUsingBlock:^(NSString *name, NSObject *object, BOOL *stop) {
        types[name] = [object class];
    }];
    return types;
}

- (instancetype)initWithScriptMessageSendFunction:(NSString *)functionName windowConstantTypes:(NSDictionary<NSString *, Class> *)constantTypes
{
    self = [super init];
    if (self == nil) {
        return nil;
    }
    
    _jsPtrCounter = 1;
    _functionImplementationMap = [NSMapTable strongToStrongObjectsMapTable];
    _constantNameToInitialMap = [NSMutableDictionary new];
    
    NSMutableSet<Class> *_objectClasses = [NSMutableSet new];
    NSMutableString *classDefinitionsScript = [NSMutableString new];
    NSMutableString *constantsScript = [NSMutableString new];
    
    [constantTypes enumerateKeysAndObjectsUsingBlock:^(NSString *constantName, Class objectClass, BOOL *stop) {
        
        // Save the object mapping
        NSInteger ptr = self->_jsPtrCounter++;
        self->_constantNameToInitialMap[constantName] = @{ @"ptr": @(ptr), @"class": objectClass };
        
        // Assign the constant
        NSString *jsClassSuffix = [[NSStringFromClass(objectClass) componentsSeparatedByString:@"."] componentsJoinedByString:@"_"]; // Swift class names have a module-name-dot prefix
        NSString *jsClassName = [@"__MRJSBridgedObject_" stringByAppendingString:jsClassSuffix];
        [constantsScript appendFormat:@"window.%@ = new %@(%ld);", constantName, jsClassName, ptr];
        
        // Convert the class signature into a JS class
        if (![_objectClasses containsObject:objectClass]) {
            
            [_objectClasses addObject:objectClass];
            [classDefinitionsScript appendFormat:@"var %@ = function(ptr) { __MRJSBridgedObject.call(this, ptr); };\n", jsClassName];
            [classDefinitionsScript appendFormat:@"%@.prototype = new __MRJSBridgedObject();\n", jsClassName];
            
            NSMutableDictionary<NSString *, MRJSWebControllerFunctionImplementationBlock> *functionImplementations = [NSMutableDictionary new];
            self->_functionImplementationMap[objectClass] = functionImplementations;
            
            Class ancestorClass = objectClass;
            while (ancestorClass != nil) {
                
                unsigned int methodCount = 0;
                Method *methodList = class_copyMethodList(ancestorClass, &methodCount);
                if (methodList != NULL) {
                    for (unsigned int i = 0; i < methodCount; i++) {
                        
                        Method method = methodList[i];
                        NSString *name = NSStringFromSelector(method_getName(method));
                        if (![name hasPrefix:@"js_"]) {
                            continue;
                        }
                        else {
                            name = [name substringFromIndex:@"js_".length];
                        }
                        
                        unsigned int argumentCount = method_getNumberOfArguments(method) - 2; // 0 = self, 1 = _cmd
                        
                        // One or more arguments: functions or setters
                        if (argumentCount >= 1) {
                            
                            // Check protocol conformance
                            if ([name hasPrefix:@"ifConformsTo"]) {
                                
                                NSString *protocolName = [name substringFromIndex:@"ifConformsTo".length];
                                NSUInteger protocolNameEnd = [protocolName rangeOfString:@"_"].location;
                                if (protocolNameEnd == NSNotFound) {
                                    continue;
                                }
                                protocolName = [protocolName substringToIndex:protocolNameEnd];
                                Protocol *protocol = NSProtocolFromString(protocolName);
                                Class protocolConformingClass = objectClass;
                                while (protocolConformingClass != nil && !class_conformsToProtocol(protocolConformingClass, protocol)) {
                                    protocolConformingClass = class_getSuperclass(protocolConformingClass);
                                }
                                
                                if (protocolConformingClass == nil) {
                                    continue;
                                }
                                
                                name = [name substringFromIndex:@"ifConformsTo".length + protocolName.length + 1];
                            }
                            
                            NSUInteger argumentDelimiterStart = [name rangeOfString:@":"].location;
                            if (argumentDelimiterStart == NSNotFound) {
                                continue;
                            }
                            else {
                                name = [name substringToIndex:argumentDelimiterStart];
                            }
                            
                            // Subclass implementations trump ancestor classes
                            if (functionImplementations[name] != nil) {
                                continue;
                            }
                            
                            NSMutableArray *argumentNames = [NSMutableArray new];
                            for (NSUInteger argIndex = 0; argIndex < argumentCount; argIndex++) {
                                [argumentNames addObject:[NSString stringWithFormat:@"arg%lu", argIndex]];
                            }
                            
                            NSString *argumentNamesString = [argumentNames componentsJoinedByString:@", "];
                            [classDefinitionsScript appendFormat:@"%@.prototype.%@ = function(%@, callback) { this.__bridgedObject_msgSend(\"%@\", [%@], callback); };\n", jsClassName, name, argumentNamesString, name, argumentNamesString];
                            
                            functionImplementations[name] = [^(id target, NSArray *arguments, MRJSWebControllerMsgSendReply reply) {
                                if (reply != nil) {
                                    id returnObject = nil;
                                    MRJSMsgSend(target, method, arguments ?: @[], &returnObject);
                                    
                                    if ([returnObject isKindOfClass:[MRJSWebPromise class]]) {
                                        reply = [reply copy];
                                        [(MRJSWebPromise *)returnObject _onFulfill:reply];
                                    }
                                    else {
                                        reply(returnObject);
                                    }
                                }
                                else {
                                    MRJSMsgSend(target, method, arguments ?: @[], NULL);
                                }
                            } copy];
                        }
                    }
                    
                    free(methodList);
                }
                
                ancestorClass = class_getSuperclass(ancestorClass);
            }
        }
    }];
    
    NSString *coreScriptPath = [[NSBundle bundleForClass:self.class] pathForResource:@"MRJSWebControllerCore" ofType:@"js"];
    NSMutableString *coreScript = [[NSString stringWithContentsOfFile:coreScriptPath usedEncoding:NULL error:NULL] ?: @"" mutableCopy];
    [coreScript replaceOccurrencesOfString:@"GENERATED_MSG_SEND" withString:functionName options:NSLiteralSearch range:NSMakeRange(0, coreScript.length)];
    [coreScript replaceOccurrencesOfString:@"/*GENERATED_INIT*/" withString:[classDefinitionsScript stringByAppendingString:constantsScript] options:NSLiteralSearch range:NSMakeRange(0, coreScript.length)];
    
    _initializationScript = coreScript;
    
    return self;
}

- (void)getInitialPtrCounter:(NSInteger *)ptrCounterPtr ptrToObjectMap:(NSMutableDictionary<NSNumber *, id> *)ptrToObjectMap objectToPtrMap:(NSMapTable<id, NSNumber *> *)objectToPtrMap withConstants:(NSDictionary<NSString *, id> *)constants
{
    (*ptrCounterPtr) = _jsPtrCounter;
    typeof(_constantNameToInitialMap) initialMap = [_constantNameToInitialMap mutableCopy];
    [constants enumerateKeysAndObjectsUsingBlock:^(NSString *constantName, id object, BOOL *stop) {
        
        NSDictionary *initial = initialMap[constantName];
        if (initial == nil) {
            [NSException raise:NSInvalidArgumentException format:@"%@: constant \"%@\" is not defined in configuration: %@", NSStringFromClass(self.class), constantName, object];
            return;
        }
        
        Class expectedClass = initial[@"class"];
        if (![object isKindOfClass:expectedClass]) {
            [NSException raise:NSInvalidArgumentException format:@"%@: constant \"%@\" is not of the expected type (%@): %@", NSStringFromClass(self.class), constantName, NSStringFromClass(expectedClass), object];
            return;
        }
        
        NSNumber *ptr = initial[@"ptr"];
        objectToPtrMap[object] = ptr;
        ptrToObjectMap[ptr] = object;
        
        [initialMap removeObjectForKey:constantName];
    }];
    
    if (initialMap.count > 0) {
        [NSException raise:NSInvalidArgumentException format:@"%@: expected constants are missing: %@", NSStringFromClass(self.class), initialMap.allKeys];
        return;
    }
}

- (MRJSWebControllerFunctionImplementationBlock)functionImplementationFor:(NSString *)cmd class:(Class)class
{
    return _functionImplementationMap[class][cmd];
}

@end


@implementation MRJSWebController
{
    NSDictionary<NSNumber *, id> *_jsPtrToObjectMap;
    NSMapTable<id, NSNumber *> *_objectToJSPtrMap;
    dispatch_queue_t _runtimeImplementationQueue;
}

- (instancetype)initWithConfiguration:(MRJSWebControllerConfiguration *)configuration windowConstants:(NSDictionary<NSString *, NSObject *> *)constants queue:(nullable dispatch_queue_t)queue
{
    self = [super init];
    if (self == nil) {
        return nil;
    }
    
    _configuration = configuration;
    _runtimeImplementationQueue = queue;
    
    NSInteger jsPtrCounter;
    NSMutableDictionary<NSNumber *, id> *jsPtrToObjectMap = [NSMutableDictionary new];
    [_configuration getInitialPtrCounter:&jsPtrCounter ptrToObjectMap:jsPtrToObjectMap objectToPtrMap:_objectToJSPtrMap withConstants:constants];
    
    _jsPtrToObjectMap = jsPtrToObjectMap;
    _objectToJSPtrMap = [NSMapTable strongToStrongObjectsMapTable];
    
    return self;
}

- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^)(id result, NSError *error))completionHandler
{
    // For subclasses
    if (completionHandler != nil) {
        completionHandler(nil, [NSError errorWithDomain:NSCocoaErrorDomain code:NSFeatureUnsupportedError userInfo:nil]);
    }
}

- (void)didReceiveScriptMessageWithBody:(id)receivedPlist scriptReplyHandler:(nullable void (^)(NSString *__nullable stringToEvaluate))evalHandler
{
    if (_runtimeImplementationQueue == nil) {
        [self _processScriptMessageWithBody:receivedPlist scriptReplyHandler:evalHandler];
    }
    else {
        evalHandler = [evalHandler copy];
        dispatch_async(_runtimeImplementationQueue, ^{
            [self _processScriptMessageWithBody:receivedPlist scriptReplyHandler:evalHandler];
        });
    }
}

- (void)_processScriptMessageWithBody:(id)receivedPlist scriptReplyHandler:(nullable void (^)(NSString *__nullable stringToEvaluate))evalHandler
{
    NSDictionary *message = MRKindOfClassOrNil(NSDictionary, receivedPlist);
    NSNumber *ptr = MRKindOfClassOrNil(NSNumber, message[@"self"]);
    NSString *cmd = MRKindOfClassOrNil(NSString, message[@"cmd"]);
    if (ptr == nil || cmd == nil) {
        NSLog(@"%@: invalid message: %@", NSStringFromClass(self.class), receivedPlist);
        if (evalHandler != nil) { evalHandler(nil); }
        return;
    }
    
    id target = _jsPtrToObjectMap[ptr];
    if (target == nil) {
        NSLog(@"%@: unknown object target: %@", NSStringFromClass(self.class), receivedPlist);
        if (evalHandler != nil) { evalHandler(nil); }
        return;
    }
    
    MRJSWebControllerFunctionImplementationBlock implementation = [_configuration functionImplementationFor:cmd class:[target class]];
    if (implementation != nil) {
        
        evalHandler = [evalHandler copy];
        
        NSArray *arguments = MRKindOfClassOrNil(NSArray, message[@"args"]) ?: @[]; // TODO: convert embedded object references
        NSNumber *replyToken = MRKindOfClassOrNil(NSNumber, message[@"reply"]);
        if (replyToken != nil) {
            implementation(target, arguments, ^(id result) {
                
                NSString *replyJSON = nil;
                if (result != nil) {
                    replyJSON = [NSJSONSerialization stringWithJSONObject:@{@"reply": replyToken, @"result": result} options:0 error:NULL];
                }
                else {
                    replyJSON = [NSJSONSerialization stringWithJSONObject:@{@"reply": replyToken} options:0 error:NULL];
                }
                
                NSString *replyScript = [NSString stringWithFormat:@"(function(){ window.__MRJS__.processMsgSendReply(%@); })();", replyJSON];
                if (evalHandler != nil) {
                    evalHandler(replyScript);
                }
                else {
                    [self evaluateJavaScript:replyScript completionHandler:nil];
                }
            });
        }
        else {
            implementation(target, arguments, nil);
            if (evalHandler != nil) { evalHandler(nil); }
        }
    }
    else {
        NSLog(@"%@: unknown function %@ called on %@", NSStringFromClass(self.class), cmd, target);
        if (evalHandler != nil) { evalHandler(nil); }
    }
}

@end
